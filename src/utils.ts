import { SrvSuccessResponse, SrvErrorResponse } from '../types/Common';

export const copy = function(obj: any, isDeep: boolean = false): any {
    if (Array.isArray(obj)) {
        return obj.map((el: any) => {
            return isDeep ? copy(el, isDeep) : el;
        });
    } else if (typeof obj === 'object' && !!obj) {
        const clone: Record<string, any> = {};

        Object.keys(obj).forEach((key: any) => {
            clone[key] = isDeep ? copy(obj[key], isDeep) : obj[key];
        });

        return clone;
    }

    return obj;
};

export const sendErrorResponse = function(srvErrorResponse: SrvErrorResponse): void {
    const {
        req,
        res,
        methodSrc,
        statusCode,
        e,
        logger,
    }: SrvErrorResponse = srvErrorResponse;

    logger.error(`${methodSrc} :: ${statusCode} :: ${JSON.stringify(e)}`);
    res.status(statusCode).send({
        error: e.message,
    });
};

export const sendSuccessResponse = function(srvSuccessResponse: SrvSuccessResponse): void {
    const {
        req,
        res,
        methodSrc,
        statusCode,
        msg,
        logger,
    }: SrvSuccessResponse = srvSuccessResponse;

    logger.info(`${methodSrc} :: ${statusCode} :: ${JSON.stringify(msg)}`);
    res.status(statusCode).send({ data: msg });
};

// CREDIT FOR THE BELOW HELPER GOES TO @gordonbrander.
// I decided to use his helper method (found here: https://gist.github.com/gordonbrander/2230317)
// instead of using a library.
//
// Generate unique IDs for use as pseudo-private/protected names.
// Similar in concept to
// <http://wiki.ecmascript.org/doku.php?id=strawman:names>.
//
// The goals of this function are twofold:
//
// * Provide a way to generate a string guaranteed to be unique when compared
//   to other strings generated by this function.
// * Make the string complex enough that it is highly unlikely to be
//   accidentally duplicated by hand (this is key if you're using `ID`
//   as a private/protected name on an object).
//
// Use:
//
//     var privateName = ID();
//     var o = { 'public': 'foo' };
//     o[privateName] = 'bar';
export const generateUniqueId = function(): string {
    // Math.random should be unique because of its seeding algorithm.
    // Convert it to base 36 (numbers + letters), and grab the first 9 characters
    // after the decimal.
    return '_' + Math.random().toString(36).substr(2, 9);
};
